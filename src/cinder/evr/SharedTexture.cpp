#include "cinder/evr/SharedTexture.h"

namespace cinder {
	namespace msw {
		namespace video {

			SharedTexture::SharedTexture( const SharedTexturePoolRef &pool, const D3DSURFACE_DESC &desc )
				: m_pPool( pool ), m_uTextureId( ~0 ), m_hGLHandle( NULL ), m_hD3DHandle( NULL ), m_pD3DSurface( NULL ), m_pD3DTexture( NULL ), m_bLocked( FALSE ), m_bResourceShared( FALSE )
			{
				HRESULT hr = S_OK;

				// Sanity check.
				assert( m_pPool.lock() );
				assert( m_pPool.lock()->GetDevice() != NULL );
#if 0
				// Create D3DSurface only.
				hr = m_pPool.lock()->GetDevice()->CreateOffscreenPlainSurface( desc.Width, desc.Height, /*D3DFMT_A8R8G8B8*/ desc.Format, D3DPOOL_DEFAULT, &m_pD3DSurface, &m_hD3DHandle );
#else
				// Create a D3DSurface from a D3DTexture.
				hr = m_pPool.lock()->GetDevice()->CreateTexture( desc.Width, desc.Height, 1, D3DUSAGE_RENDERTARGET, /*D3DFMT_A8R8G8B8*/ desc.Format, D3DPOOL_DEFAULT, &m_pD3DTexture, &m_hD3DHandle );
				if( SUCCEEDED( hr ) )
					hr = m_pD3DTexture->GetSurfaceLevel( 0, &m_pD3DSurface );
#endif
				if( !SUCCEEDED( hr ) )
					CI_LOG_E( "Failed to create D3DSurface." );
			}

			bool SharedTexture::Share()
			{
				// Sanity check.
				assert( m_pPool.lock() );

				if( !m_hGLHandle ) {
					CI_LOG_V( "Share(" << m_pD3DSurface << ")" );

					// Only need to share the resource once over the lifetime of the surface.
					if( !m_bResourceShared && !wglDXSetResourceShareHandleNV( m_pD3DSurface, m_hD3DHandle ) ) {
						CI_LOG_V( "Failed to share D3DSurface with OpenGL." );
						return false;
					}
					m_bResourceShared = TRUE;

					// Create texture id.
					if( !glIsTexture( m_uTextureId ) ) {
						glGenTextures( 1, &m_uTextureId );
						CI_LOG_V( "glGenTextures(" << m_uTextureId << ")" );

						// 
						m_hGLHandle = wglDXRegisterObjectNV( m_pPool.lock()->GetDeviceHandle(), m_pD3DSurface, m_uTextureId, GL_TEXTURE_RECTANGLE, WGL_ACCESS_READ_ONLY_NV );
						if( !m_hGLHandle ) {
							DWORD err = GetLastError();
							switch( err ) {
							case ERROR_INVALID_HANDLE:
								CI_LOG_E( "Failed to register D3DSurface with OpenGL: Invalid Handle." );
								break;
							case ERROR_INVALID_DATA:
								CI_LOG_E( "Failed to register D3DSurface with OpenGL: Invalid Data." );
								break;
							case ERROR_OPEN_FAILED:
								CI_LOG_E( "Failed to register D3DSurface with OpenGL: Open Failed." );
								break;
							default:
								CI_LOG_E( "Failed to register D3DSurface with OpenGL: Unknown Error." );
								break;
							}

							CI_LOG_V( "glDeleteTextures(" << m_uTextureId << ")" );
							glDeleteTextures( 1, &m_uTextureId );
							m_uTextureId = 0;
						}
					}
				}

				return ( m_hGLHandle != NULL );
			}

			bool SharedTexture::Unshare()
			{
				CI_LOG_V( "Unshare(" << m_pD3DSurface << ")" );

				// Try to unregister.
				if( m_pPool.lock() ) {
					if( m_hGLHandle != NULL ) {
						if( !wglDXUnregisterObjectNV( m_pPool.lock()->GetDeviceHandle(), m_hGLHandle ) ) {
							CI_LOG_E( "Failed to unregister D3DSurface." );
							return false;
						}
					}
				}

				// 
				m_hGLHandle = NULL;

				if( glIsTexture( m_uTextureId ) ) {
					CI_LOG_V( "glDeleteTextures(" << m_uTextureId << ")" );
					glDeleteTextures( 1, &m_uTextureId );
					m_uTextureId = 0;
				}

				return true;
			}

			gl::Texture2dRef SharedTexture::Lock()
			{
				gl::Texture2dRef texture = m_pGLTexture.lock();

				// Return existing texture if we're already in a locked state.
				if( m_bLocked && texture )
					return texture;

				CI_LOG_V( "Lock(" << m_pD3DSurface << ")" );

				// Sanity check.
				assert( m_pD3DSurface != NULL );

				HRESULT hr = S_OK;

				// Create texture if we don't have one.
				if( !texture ) {
					// Define a custom deleter for the texture.
					std::weak_ptr<SharedTexturePool> weakPtr = m_pPool;
					auto deleter = [weakPtr]( gl::Texture2d *pTexture ) {
						// Check if the pool still exists.
						std::shared_ptr<SharedTexturePool> pool = weakPtr.lock();
						if( pool ) {
							pool->FreeUsedTexture( pTexture );
						}
						else {
							// Pool no longer exists. Delete the texture in the usual way.
							pTexture->setDoNotDispose( false );
							delete pTexture;
						}
					};

					// Obtain size and format of the texture.
					D3DSURFACE_DESC desc;
					hr = m_pD3DSurface->GetDesc( &desc );

					if( SUCCEEDED( hr ) ) {
						// Since we're gonna use a bitmap generated by DirectX, all we need to do is
						// generate an OpenGL texture ID and wrap it within a gl::Texture2d instance.

						// Try to share the 3D surface with OpenGL.
						if( Share() ) {
							// Create the texture and make sure the texture is not rendered upside down.
							texture = gl::Texture2d::create( GL_TEXTURE_RECTANGLE, m_uTextureId, desc.Width, desc.Height, true, deleter );
							texture->setTopDown( true );

							// Store a weak pointer to the texture. We don't own it, the application does. This way, we can detect when it has gone out of scope.
							m_pGLTexture = std::weak_ptr<gl::Texture2d>( texture );
						}
					}
				}

				// Lock the texture.
				if( texture ) {
					// Sanity check.
					assert( m_pPool.lock() );

					if( !wglDXLockObjectsNV( m_pPool.lock()->GetDeviceHandle(), 1, &m_hGLHandle ) ) {
						CI_LOG_E( "Failed to lock the OpenGL texture." );
						return gl::Texture2dRef();
					}

					m_bLocked = TRUE;
				}

				return texture;
			}

			void SharedTexture::Unlock()
			{
				if( m_bLocked ) {
					CI_LOG_V( "Unlock(" << m_pD3DSurface << ")" );

					// Sanity check.
					assert( m_pPool.lock() );

					//if( wglDXUnlockObjectsNV( m_pPool.lock()->GetDeviceHandle(), 1, &m_hGLHandle ) ) {
						m_bLocked = FALSE;
					//}
					//else {
					//	CI_LOG_E( "Failed to unlock the OpenGL texture." );
					//}
				}
			}

			HRESULT SharedTexture::BlitTo( IDirect3DDevice9Ex *pDevice, IDirect3DSurface9 *pSurface )
			{
				CI_LOG_V( "BlitTo(" << m_pD3DSurface << ")" );

				// Sanity check.
				assert( pDevice != NULL );
				assert( pSurface != NULL );
				assert( m_pPool.lock() );
				assert( m_pPool.lock()->GetDevice() == pDevice );

				// Blit.
				HRESULT hr = pDevice->StretchRect( pSurface, NULL, m_pD3DSurface, NULL, D3DTEXF_NONE );

				if( SUCCEEDED( hr ) ) {
#if 0
					// Create an event query.
					ScopedComPtr<IDirect3DQuery9> pEventQuery;
					hr = pDevice->CreateQuery( D3DQUERYTYPE_EVENT, &pEventQuery );

					// Wait for the operation to complete.
					if( SUCCEEDED( hr ) ) {
						pEventQuery->Issue( D3DISSUE_END );

						while( S_FALSE == pEventQuery->GetData( NULL, 0, D3DGETDATA_FLUSH ) ) {
							CI_LOG_V( "Sleep(" << m_pD3DSurface << ")" );
							::Sleep( 1 );
						}
					}
#endif
					// Make surface available to OpenGL.
					m_pPool.lock()->AddAvailableSurface( shared_from_this() );
				}
				else {
					CI_LOG_E( "Failed to blit to D3DSurface (" << hr << ")." );
				}

				return hr;
			}
		}
	}
}