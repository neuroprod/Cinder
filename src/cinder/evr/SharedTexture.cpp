#include "cinder/evr/SharedTexture.h"

namespace cinder {
	namespace msw {
		namespace video {

			SharedTexture::SharedTexture( const SharedTexturePoolRef &pool, const D3DSURFACE_DESC &desc )
				: m_pPool( pool ), m_uTextureId( ~0 ), m_hGLHandle( NULL ), m_hD3DHandle( NULL ), m_pD3DSurface( NULL ), m_pD3DTexture( NULL ), m_bLocked( FALSE )
			{
				HRESULT hr = S_OK;

				// Sanity check.
				assert( m_pPool.lock() );
				assert( m_pPool.lock()->GetDevice() != NULL );
#if 1
				// Create D3DSurface only.
				hr = m_pPool.lock()->GetDevice()->CreateOffscreenPlainSurface( desc.Width, desc.Height, /*D3DFMT_A8R8G8B8*/ desc.Format, D3DPOOL_DEFAULT, &m_pD3DSurface, &m_hD3DHandle );
#else
				// Create a D3DSurface from a D3DTexture.
				hr = m_pPool.lock()->GetDevice()->CreateTexture( desc.Width, desc.Height, 1, D3DUSAGE_RENDERTARGET, /*D3DFMT_A8R8G8B8*/ desc.Format, D3DPOOL_DEFAULT, &m_pD3DTexture, &m_hD3DHandle );
				if( SUCCEEDED( hr ) )
					hr = m_pD3DTexture->GetSurfaceLevel( 0, &m_pD3DSurface );
#endif
				if( !SUCCEEDED( hr ) )
					CI_LOG_E( "Failed to create D3DSurface." );
			}

			bool SharedTexture::Share()
			{
				// Sanity check.
				assert( m_pPool.lock() );

				if( !m_hGLHandle ) {
					if( !wglDXSetResourceShareHandleNV( m_pD3DSurface, m_hD3DHandle ) ) {
						CI_LOG_E( "Failed to share D3DSurface with OpenGL." );
						return false;
					}

					m_hGLHandle = wglDXRegisterObjectNV( m_pPool.lock()->GetDeviceHandle(), m_pD3DSurface, m_uTextureId, GL_TEXTURE_RECTANGLE, WGL_ACCESS_READ_ONLY_NV );
					if( !m_hGLHandle ) {
						DWORD err = GetLastError();
						switch( err ) {
						case ERROR_INVALID_HANDLE:
							CI_LOG_E( "Failed to register D3DSurface with OpenGL: Invalid Handle." );
							break;
						case ERROR_INVALID_DATA:
							CI_LOG_E( "Failed to register D3DSurface with OpenGL: Invalid Data." );
							break;
						case ERROR_OPEN_FAILED:
							CI_LOG_E( "Failed to register D3DSurface with OpenGL: Open Failed." );
							break;
						default:
							CI_LOG_E( "Failed to register D3DSurface with OpenGL: Unknown Error." );
							break;
						}
					}
				}

				return ( m_hGLHandle != NULL );
			}

			bool SharedTexture::Unshare()
			{
				// Sanity check.
				if( m_pPool.lock() ) {
					if( m_hGLHandle != NULL ) {
						if( wglDXUnregisterObjectNV( m_pPool.lock()->GetDeviceHandle(), m_hGLHandle ) ) {
							m_hGLHandle = NULL;
						}
						else {
							CI_LOG_E( "Failed to unregister D3DSurface." );
						}
					}
				}
				else {
					m_hGLHandle = NULL;
				}

				return ( m_hGLHandle == NULL );
			}

			gl::Texture2dRef SharedTexture::Lock()
			{
				gl::Texture2dRef texture = m_pGLTexture.lock();

				// Return existing texture if we're already in a locked state.
				if( m_bLocked && texture )
					return texture;

				// Sanity check.
				assert( m_pD3DSurface != NULL );

				HRESULT hr = S_OK;

				// Create texture if we don't have one.
				if( !texture ) {
					// Define a custom deleter for the texture.
					std::weak_ptr<SharedTexturePool> weakPtr = m_pPool;
					auto deleter = [weakPtr]( gl::Texture2d *pTexture ) {
						// Check if the pool still exists.
						std::shared_ptr<SharedTexturePool> pool = weakPtr.lock();
						if( pool ) {
							pool->FreeUsedTexture( pTexture );
						}
						else {
							// Pool no longer exists. Delete the texture in the usual way.
							pTexture->setDoNotDispose( false );
							delete pTexture;
						}
					};

					// Obtain size and format of the texture.
					D3DSURFACE_DESC desc;
					hr = m_pD3DSurface->GetDesc( &desc );

					if( SUCCEEDED( hr ) ) {
						// Since we're gonna use a bitmap generated by DirectX, all we need to do is
						// generate an OpenGL texture ID and wrap it within a gl::Texture2d instance.
#if 1
						if( !glIsTexture( m_uTextureId ) )
							glGenTextures( 1, &m_uTextureId );

						// Create the texture and make sure the texture is not rendered upside down.
						texture = gl::Texture2d::create( GL_TEXTURE_RECTANGLE, m_uTextureId, desc.Width, desc.Height, true, deleter );
						texture->setTopDown( true );
#else
						texture = gl::Texture2d::create( desc.Width, desc.Height );
						texture->setTopDown( true );

						m_uTextureId = texture->getId();
#endif
						// Store a weak pointer to the texture. We don't own it, the application does. This way, we can detect when it has gone out of scope.
						m_pGLTexture = std::weak_ptr<gl::Texture2d>( texture );

						// Try to share the 3D surface with OpenGL.
						if( !Share() ) {
							texture->setDoNotDispose( false );
							texture.reset();

							m_uTextureId = ~0;
						}
					}
				}

				// Lock the texture.
				if( texture ) {
					// Sanity check.
					assert( m_pPool.lock() );

					if( !wglDXLockObjectsNV( m_pPool.lock()->GetDeviceHandle(), 1, &m_hGLHandle ) ) {
						CI_LOG_E( "Failed to lock the OpenGL texture." );
						return gl::Texture2dRef();
					}

					m_bLocked = TRUE;
				}

				return texture;
			}

			void SharedTexture::Unlock()
			{
				if( m_bLocked ) {
					// Sanity check.
					assert( m_pPool.lock() );

					if( wglDXUnlockObjectsNV( m_pPool.lock()->GetDeviceHandle(), 1, &m_hGLHandle ) ) {
						m_bLocked = FALSE;
					}
					else {
						CI_LOG_E( "Failed to unlock the OpenGL texture." );
					}
				}
			}

			HRESULT SharedTexture::BlitTo( IDirect3DDevice9Ex *pDevice, IDirect3DSurface9 *pSurface )
			{
				// Sanity check.
				assert( pDevice != NULL );
				assert( pSurface != NULL );
				assert( m_pPool.lock() );
				assert( m_pPool.lock()->GetDevice() == pDevice );

				// Blit.
				HRESULT hr = pDevice->StretchRect( pSurface, NULL, m_pD3DSurface, NULL, D3DTEXF_NONE );

				if( SUCCEEDED( hr ) ) {
					// Create an event query.
					ScopedComPtr<IDirect3DQuery9> pEventQuery;
					hr = pDevice->CreateQuery( D3DQUERYTYPE_EVENT, &pEventQuery );

					// Wait for the operation to complete.
					if( SUCCEEDED( hr ) ) {
						pEventQuery->Issue( D3DISSUE_END );

						while( S_FALSE == pEventQuery->GetData( NULL, 0, D3DGETDATA_FLUSH ) )
							::Sleep( 1 );
					}

					// Make surface available to OpenGL.
					m_pPool.lock()->AddAvailableSurface( shared_from_this() );
				}
				else {
					CI_LOG_E( "Failed to blit to D3DSurface (" << hr << ")." );
				}

				return hr;
			}
		}
	}
}